'use client';

/**
 * useOfflinePhotos Hook
 * Provides reactive access to offline photo queue with auto-sync capabilities
 */

import { useState, useEffect, useCallback } from 'react';
import {
  getOfflinePhotoService,
  PendingPhoto,
  PhotoCategory,
  UploadResult,
  UploadProgress,
} from '@/lib/offline/offline-photos';
import { useNetworkStatus } from '@/lib/offline/network-status';
import { useAuth } from '@/lib/auth';
import { toast } from '@/components/ui/Toast';

interface UseOfflinePhotosOptions {
  projectId?: string;
  autoSync?: boolean;
}

interface UseOfflinePhotosReturn {
  // Data
  pendingPhotos: PendingPhoto[];
  pendingCount: number;
  failedCount: number;
  isOnline: boolean;
  isSyncing: boolean;

  // Actions
  queuePhoto: (params: QueuePhotoParams) => Promise<string | null>;
  syncAll: () => Promise<UploadResult | null>;
  retryFailed: () => Promise<UploadResult | null>;
  deletePendingPhoto: (localId: string) => Promise<void>;
  updatePendingPhoto: (localId: string, updates: Partial<PendingPhoto>) => Promise<void>;

  // Progress
  uploadProgress: UploadProgress | null;
}

interface QueuePhotoParams {
  blob: Blob;
  projectId: string;
  category?: PhotoCategory;
  caption?: string;
  phaseId?: string;
  albumId?: string;
  taskId?: string;
  location?: { lat: number; lng: number };
}

export function useOfflinePhotos(options: UseOfflinePhotosOptions = {}): UseOfflinePhotosReturn {
  const { projectId, autoSync = true } = options;
  const { user, profile } = useAuth();
  const { isOnline, wasOffline } = useNetworkStatus();

  const [pendingPhotos, setPendingPhotos] = useState<PendingPhoto[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);
  const [uploadProgress, setUploadProgress] = useState<UploadProgress | null>(null);

  const service = getOfflinePhotoService();

  // Load pending photos
  const loadPhotos = useCallback(async () => {
    try {
      const photos = projectId
        ? await service.getPendingPhotosForProject(projectId)
        : await service.getPendingPhotos();

      // Only show non-completed photos
      setPendingPhotos(photos.filter((p) => p.syncStatus !== 'completed'));
    } catch (error) {
      console.error('Failed to load pending photos:', error);
    }
  }, [projectId, service]);

  // Subscribe to changes
  useEffect(() => {
    loadPhotos();

    const unsubscribe = service.subscribeToQueueChanges(() => {
      loadPhotos();
    });

    return unsubscribe;
  }, [loadPhotos, service]);

  // Auto-sync when coming back online
  useEffect(() => {
    if (autoSync && isOnline && wasOffline && pendingPhotos.length > 0 && !isSyncing) {
      const timer = setTimeout(() => {
        syncAll();
      }, 3000); // 3 second delay after reconnection

      return () => clearTimeout(timer);
    }
  }, [isOnline, wasOffline, autoSync]); // eslint-disable-line react-hooks/exhaustive-deps

  // Queue a new photo
  const queuePhoto = useCallback(
    async (params: QueuePhotoParams): Promise<string | null> => {
      if (!user || !profile?.orgId) {
        toast.error('You must be logged in to capture photos');
        return null;
      }

      try {
        const localId = await service.queuePhoto({
          projectId: params.projectId,
          orgId: profile.orgId,
          userId: user.uid,
          userName: profile.displayName || profile.email || 'Unknown',
          blob: params.blob,
          thumbnail: '', // Generated by service
          filename: `photo_${Date.now()}.jpg`,
          category: params.category || 'progress',
          caption: params.caption,
          takenAt: Date.now(),
          location: params.location,
          phaseId: params.phaseId,
          albumId: params.albumId,
          taskId: params.taskId,
        });

        toast.success('Photo saved offline');

        // If online, attempt immediate upload
        if (isOnline && autoSync) {
          setTimeout(() => {
            service.uploadPhoto(localId).catch(console.error);
          }, 500);
        }

        return localId;
      } catch (error) {
        console.error('Failed to queue photo:', error);
        toast.error('Failed to save photo');
        return null;
      }
    },
    [user, profile, service, isOnline, autoSync]
  );

  // Sync all pending photos
  const syncAll = useCallback(async (): Promise<UploadResult | null> => {
    if (!isOnline) {
      toast.error('No network connection');
      return null;
    }

    if (isSyncing) {
      return null;
    }

    setIsSyncing(true);
    setUploadProgress(null);

    try {
      const result = await service.processUploadQueue((progress) => {
        setUploadProgress(progress);
      });

      if (result.successful > 0) {
        toast.success(`${result.successful} photo${result.successful > 1 ? 's' : ''} uploaded`);
      }

      if (result.failed > 0) {
        toast.error(`${result.failed} upload${result.failed > 1 ? 's' : ''} failed`);
      }

      await loadPhotos();
      return result;
    } catch (error) {
      console.error('Sync failed:', error);
      toast.error('Sync failed');
      return null;
    } finally {
      setIsSyncing(false);
      setUploadProgress(null);
    }
  }, [isOnline, isSyncing, service, loadPhotos]);

  // Retry failed uploads
  const retryFailed = useCallback(async (): Promise<UploadResult | null> => {
    if (!isOnline) {
      toast.error('No network connection');
      return null;
    }

    try {
      const result = await service.retryFailedUploads();
      await loadPhotos();
      return result;
    } catch (error) {
      console.error('Retry failed:', error);
      toast.error('Retry failed');
      return null;
    }
  }, [isOnline, service, loadPhotos]);

  // Delete pending photo
  const deletePendingPhoto = useCallback(
    async (localId: string) => {
      try {
        await service.deletePendingPhoto(localId);
        await loadPhotos();
      } catch (error) {
        console.error('Failed to delete photo:', error);
        throw error;
      }
    },
    [service, loadPhotos]
  );

  // Update pending photo
  const updatePendingPhoto = useCallback(
    async (localId: string, updates: Partial<PendingPhoto>) => {
      try {
        await service.updatePendingPhoto(localId, updates);
        await loadPhotos();
      } catch (error) {
        console.error('Failed to update photo:', error);
        throw error;
      }
    },
    [service, loadPhotos]
  );

  // Computed values
  const pendingCount = pendingPhotos.filter(
    (p) => p.syncStatus === 'pending' || p.syncStatus === 'uploading'
  ).length;

  const failedCount = pendingPhotos.filter((p) => p.syncStatus === 'failed').length;

  return {
    pendingPhotos,
    pendingCount,
    failedCount,
    isOnline,
    isSyncing,
    queuePhoto,
    syncAll,
    retryFailed,
    deletePendingPhoto,
    updatePendingPhoto,
    uploadProgress,
  };
}
